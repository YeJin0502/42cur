// 보너스 헤더와 다르다. 보너스 채점은 보너스 헤더를 호출하기때문이다.
#include "get_next_line.h"

// line은 읽은 파일의 내용을 저장하기 위한 공간이다.
// 그러니까 asd123'\n'456789 내용을 가진 파일이 있고,
// BUFFER_SIZE가 3이라면,
// line에는 asd->asd123->출력
// 456->456789->출력이 된다.

// 개행문자는 왜 안넣는지 모르겠지만 채점 서버가 puts라는 함수로 출력하는것 같다.
int	get_next_line(int fd, char **line)
{
	static char		*buf[OPEN_MAX];			// gnl과 gnl bonus소스가 같다.
											// gnl은 파일 1개만 불러와도 되지만 보너스와 같은 방식으로 소스를 작성했다.
											// 2차원 배열로 미리 2차원 배열로 선언한 이유는 동작성에 있어서 너무 비효율적이기 때문이다.
											// **buf라는 변수로 선언해서 파일을 여러개 있었을 경우
											// 세로축 할당이 몇개나 될지 모르기떄문에 그때그때 할당해제를 하고 다시 복사해줘야 하는 과정
											// 자체가 너무 비효율적이다. OPEN_MAX를 공부해보면 알겠지만 시스템마다 정해져있다.
											// OPEN_MAX가 너무 크다면 **buf라고 선언했을때 시간복잡도와 공간복잡도가 너무 난잡해진다.
											// 그렇기 떄문에 사용자 PC선에서 그러니까 프로세스당 열수 있는 OPEN_MAX의 개수를 정해서 진행했다.
	int				sz;						// 읽은 버퍼 사이즈를 저장히기 위한 변수

	// fd가 0보다 작다면? 파일 읽기에 실패한 경우이고,
	// BUFFER_SIZE가 0보다 작다면 파일을 읽을 수 없다.
	// OPEN_MAX가 fd보다 작거나 같다면 더이상 복사할 공간이 없다.
	// !line은 line변수 자체가 null로 주어진다면 복사를 할수 없기 떄문에 체크해줬다.

	// RET_ERROR, RET_SUCCESS, RET_EOF 는 헤더 파일에 선언되어 있다.
	if (fd < 0 || BUFFER_SIZE <= 0 || OPEN_MAX <= fd || !line)
		return (RET_ERROR);
	
	// 현재 fd의 위치가 할당되어 있지 않다면 뒤에 있는 조건을 검사한다.
	// 뒤에 조건을 검사하기전에 먼저 할당을 하고, 할당 실패시 에러를 반환한다.
	// 그러니까 파일을 제대로 읽을 수 있는 환경이면서 파일을 제대로 열었다면 무조건 fd위치에 1번의 할당이 이루어진다.
	if (!*(buf + fd) && !(*(buf + fd) = ft_calloc(BUFFER_SIZE + 1, 1)))
		return (RET_ERROR);
	
	// 복사를 하기 위해 line을 NULL로 초기화를 하고,
	*line = 0;

	// 먼저 버퍼에 잔여물이 있다면 버퍼에 있는걸 line에 복사한다.
	// 버퍼에 아무것도 없다면 그러니까 처음 읽는다면 이 과정에서 아무것도 복사되지 않는다.
	if (ft_strappend(line, *(buf + fd)))
		return (RET_SUCCESS);

	// read함수의 반환값은 읽은 파일의 길이가 반환된다.
	// sz가 0이라면 EOF를 만난것이고, 0보다 작다면 read함수의 오류이기 떄문에 이런조건이 필요하다.
	// BUFFER_SIZE만큼 fd의 위치에 파일을 읽어주고
	while ((sz = read(fd, *(buf + fd), BUFFER_SIZE)) > 0)
	{
		// read함수는 문자열의 끝인 0을 보장해주지 않기떄문에 임의로 넣어준다.
		*(*(buf + fd) + sz) = 0;
		// 그리고 append로
		if (ft_strappend(line, *(buf + fd)))
			return (RET_SUCCESS);
	}

	// 이 아래로 내려오는 경우는 EOF를 만났거나, 아니면 read의 오류인 경우이다.
	// 그러니 sz가 0보다 작은경우 기존 line을 할당해제 해주고 ERROR를
	// 아니라면 EOF를 반환해준다.
	// 그렇다면 오류인 겨우는 무엇일까?
	// 하나 가정을 해본다면, 위에 반복문에서 파일을 잘 읽던 도중에 파일에 문제가 생겼다고 해보자.
	// 가령 읽는 도중에 삭제가 되었다던가?
	// 그렇다면 이걸 왜 free해줘야하나?
	// 일단 line은 main에서 출력하고 free하는 구도를 가지고 있다.
	// 그런데 제대로 읽히지 않았다면 free하지 않는 경우가 발생할 수 있기때문에 임의로 free해준것이다.
	// GNL자체에서 line을 free 하는 경우는 잘못 읽었을때와, 그리고 새로운걸 다시 복사할떄 뿐이다.
	if (sz < 0)
		ft_free(line);
	// 앞전에도 이야기 했듯 여기까지 내려오는 경우는 EOF를 만났거나 ERROR인 경우이다.
	// 그러니 최초로 열었을때 할당 해두었던곳은 무조건 할당해제 해줘야한다.
	ft_free(buf + fd);
	// 에러인지 EOF인지
	return (sz < 0 ? RET_ERROR : RET_EOF);
}
